From 5f47d0bfe8c9cd4215b7154cc93c65e3a3cf9d50 Mon Sep 17 00:00:00 2001
From: percy-g2 <gahlotpercy@gmail.com>
Date: Thu, 8 May 2014 19:17:49 +0530
Subject: [PATCH] STE_MULTIMEDIA:STEP1

---
 cmds/stagefright/recordvideo.cpp                   | 62 +++++++++++++++++-----
 .../libmediaplayerservice/StagefrightRecorder.cpp  | 15 +++++-
 media/libstagefright/OMXCodec.cpp                  |  2 +
 3 files changed, 65 insertions(+), 14 deletions(-)

diff --git a/cmds/stagefright/recordvideo.cpp b/cmds/stagefright/recordvideo.cpp
index c30c122..090eada 100644
--- a/cmds/stagefright/recordvideo.cpp
+++ b/cmds/stagefright/recordvideo.cpp
@@ -45,19 +45,21 @@ static void usage(const char *me) {
     fprintf(stderr, "       -v video codec: [0] AVC [1] M4V [2] H263 (default: 0)\n");
     fprintf(stderr, "       -s(oftware) prefer software codec\n");
     fprintf(stderr, "       -o filename: output file (default: /sdcard/output.mp4)\n");
+    fprintf(stderr, "       -y YUV file input (default: NULL)\n");
     exit(1);
 }
 
 class DummySource : public MediaSource {
 
 public:
-    DummySource(int width, int height, int nFrames, int fps, int colorFormat)
+    DummySource(int width, int height, int nFrames, int fps, int colorFormat, int fd)
         : mWidth(width),
           mHeight(height),
           mMaxNumFrames(nFrames),
           mFrameRate(fps),
           mColorFormat(colorFormat),
-          mSize((width * height * 3) / 2) {
+          mSize((width * height * 3) / 2),
+          mFd((FILE*)fd){
 
         mGroup.add_buffer(new MediaBuffer(mSize));
     }
@@ -83,6 +85,7 @@ public:
 
     virtual status_t read(
             MediaBuffer **buffer, const MediaSource::ReadOptions *options) {
+        int bytesCopied = 0;
 
         if (mNumFramesOutput % 10 == 0) {
             fprintf(stderr, ".");
@@ -96,22 +99,39 @@ public:
             return err;
         }
 
+        // Read a YUV frame from the file into the buffer
+        if (mFd != NULL) {
+            bytesCopied = fread((*buffer)->data(), 1, mSize, mFd);
+        }
+
         // We don't care about the contents. we just test video encoder
         // Also, by skipping the content generation, we can return from
         // read() much faster.
         //char x = (char)((double)rand() / RAND_MAX * 255);
         //memset((*buffer)->data(), x, mSize);
-        (*buffer)->set_range(0, mSize);
-        (*buffer)->meta_data()->clear();
-        (*buffer)->meta_data()->setInt64(
-                kKeyTime, (mNumFramesOutput * 1000000) / mFrameRate);
-        ++mNumFramesOutput;
-
-        return OK;
+        if (mFd == NULL || bytesCopied == mSize) {
+            (*buffer)->set_range(0, mSize);
+            (*buffer)->meta_data()->clear();
+            (*buffer)->meta_data()->setInt64(kKeyTime,(mNumFramesOutput * 1000000) / mFrameRate);
+
+            ++mNumFramesOutput;
+            return OK;
+        } else {
+            if (mFd != NULL) {
+                fclose(mFd);
+            }
+            mFd = NULL;
+            return ERROR_END_OF_STREAM;
+        }
     }
 
 protected:
-    virtual ~DummySource() {}
+    virtual ~DummySource() {
+        if (mFd != NULL) {
+            fclose(mFd);
+            mFd = NULL;
+        }
+    }
 
 private:
     MediaBufferGroup mGroup;
@@ -120,7 +140,8 @@ private:
     int mFrameRate;
     int mColorFormat;
     size_t mSize;
-    int64_t mNumFramesOutput;;
+    int64_t mNumFramesOutput;
+    FILE* mFd;
 
     DummySource(const DummySource &);
     DummySource &operator=(const DummySource &);
@@ -129,6 +150,7 @@ private:
 enum {
     kYUV420SP = 0,
     kYUV420P  = 1,
+    kYUV420MB = 2,
 };
 
 // returns -1 if mapping of the given color is unsuccessful
@@ -139,6 +161,9 @@ static int translateColorToOmxEnumValue(int color) {
             return OMX_COLOR_FormatYUV420SemiPlanar;
         case kYUV420P:
             return OMX_COLOR_FormatYUV420Planar;
+        case kYUV420MB:
+            // STE proprietory color format
+            return OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB;
         default:
             fprintf(stderr, "Custom OMX color format: %d\n", color);
             if (color == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar ||
@@ -162,12 +187,13 @@ int main(int argc, char **argv) {
     int level = -1;        // Encoder specific default
     int profile = -1;      // Encoder specific default
     int codec = 0;
+    FILE *fd = NULL;
     char *fileName = "/sdcard/output.mp4";
     bool preferSoftwareCodec = false;
 
     android::ProcessState::self()->startThreadPool();
     int res;
-    while ((res = getopt(argc, argv, "b:c:f:i:n:w:t:l:p:v:o:hs")) >= 0) {
+    while ((res = getopt(argc, argv, "b:c:f:i:n:w:t:l:p:v:o:y:hs")) >= 0) {
         switch (res) {
             case 'b':
             {
@@ -241,6 +267,16 @@ int main(int argc, char **argv) {
                 break;
             }
 
+            case 'y':
+            {
+                fd = fopen(optarg,"rb");
+                if (fd == NULL) {
+                    fprintf(stderr, "Error: Unable to open the file\n");
+                    return -1;
+                }
+            }
+            break;
+
             case 's':
             {
                 preferSoftwareCodec = true;
@@ -261,7 +297,7 @@ int main(int argc, char **argv) {
 
     status_t err = OK;
     sp<MediaSource> source =
-        new DummySource(width, height, nFrames, frameRateFps, colorFormat);
+        new DummySource(width, height, nFrames, frameRateFps, colorFormat, (int)fd);
 
     sp<MetaData> enc_meta = new MetaData;
     switch (codec) {
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index f9d9020..12b68d2 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -43,6 +43,9 @@
 #include <camera/CameraParameters.h>
 #include <gui/Surface.h>
 
+#include <utils/String8.h>
+#include <cutils/properties.h>
+
 #include <utils/Errors.h>
 #include <sys/types.h>
 #include <ctype.h>
@@ -52,6 +55,8 @@
 
 #include "ARTPWriter.h"
 
+#define DEFAULT_VIDEO_ENCODER "ro.default.video.encoder"
+
 namespace android {
 
 // To collect the encoder usage for the battery app
@@ -172,8 +177,16 @@ status_t StagefrightRecorder::setVideoEncoder(video_encoder ve) {
         return BAD_VALUE;
     }
 
+    // Read DEFAULT_VIDEO_ENCODER and set the default video encoder
+    video_encoder defaultEncoder = VIDEO_ENCODER_H263;
+    char value[PROPERTY_VALUE_MAX];
+    property_get(DEFAULT_VIDEO_ENCODER, value, "");
+    if (strncmp(value, "h264", 4) == 0) {
+        defaultEncoder = VIDEO_ENCODER_H264;
+    }
+
     if (ve == VIDEO_ENCODER_DEFAULT) {
-        mVideoEncoder = VIDEO_ENCODER_H263;
+        mVideoEncoder = defaultEncoder;
     } else {
         mVideoEncoder = ve;
     }
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index a8d6342..0452bcd 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -239,6 +239,8 @@ uint32_t OMXCodec::OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
             return HAL_PIXEL_FORMAT_YCBCR42XMBN;
         case OMX_COLOR_FormatYUV420Planar:
             return HAL_PIXEL_FORMAT_YCbCr_420_P;
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP;
         default:
             ALOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
             return omxValue;
-- 
1.9.1

